#!/usr/bin/env ruby
ENV['RAILS_ENV'] = 'production'
require File.dirname(__FILE__) + '/../config/boot'
require File.dirname(__FILE__) + '/../config/environment'
require 'builder'
require 'schedule_helper'
include ScheduleHelper
include ApplicationHelper
require 'ftools'
require 'set'
require 'RMagick'
require 'base64'

@export_sql = false

# keep it here until it's stored in Pentabarf:
# (hash values are [ lat, long ])
# use this: http://www.europe-camping-guide.com/get-longitude-latitude-google-maps/
@room_geo = {
  'h2214'      => [ '50.81290582134759', '4.3803611397743225' ],
  'janson'     => [ '50.81325663668648', '4.37966912984848' ],
  'chavanne'   => [ '50.81254991903593', '4.382069706916809' ],
  'ferrer'     => [ '50.812883789378475', '4.380328953266144' ],
  'lameere'    => [ '50.812039787659984', '4.382337927818298' ],
  'h3227'      => [ '50.81291937947728', '4.380280673503876' ],
  'h1301'      => [ '50.81264313180825', '4.379730820655823' ],
  'h1302'      => [ '50.812687195963115', '4.379897117614746' ],
  'h1308'      => [ '50.81273295484919', '4.380033910274506' ],
  'h1309'      => [ '50.81276854506295', '4.380189478397369' ],
  'h2213'      => [ '50.81287362077382', '4.380377233028412' ],
  'guillissen' => [ '50.81176522959664', '4.382879734039307' ],
  'ua2114'     => [ '50.81176522959664', '4.383099675178528' ],
  'aw1105'     => [ '50.81203809286208', '4.380693733692169' ],
  'aw1115'     => [ '50.81224485775319', '4.3805475533008575' ],
  'aw1117'     => [ '50.81227112699761', '4.380617290735245' ],
  'aw1120'     => [ '50.812303327986754', '4.380767494440079' ],
  'aw1121'     => [ '50.81227960094425', '4.3808358907699585' ],
  'aw1124'     => [ '50.812201640577015', '4.38085600733757' ],
  'aw1125'     => [ '50.81213639103922', '4.380936473608017' ],
  'aw1126'     => [ '50.812161812947906', '4.380939155817032' ],
}

@lang = 'en'
@language = 'English'
@here = Dir.pwd
@timezone = 'Europe/Brussels'
@conference = Conference.select_single(:acronym=>ARGV[0])
@output_dir = "#{@here}/tmp/fosdem-export/#{@conference.acronym}"
@grid_max_columns = 7
@grid_max_title_length = 25
@mobile_base_url = 'http://m.fosdem.org/'
#begin
  #u = URI.parse(@conference.export_base_url)
  #u.path = u.path.split('/').slice((0..-2)).join('/') + '/mobile/'
  #@mobile_base_url = u.to_s
#end

IMAGE_SIZES = [22,32,48,128]

#languages = View_conference_language.select(:conference_id=>@conference.conference_id,:translated=>'en')
#languages = languages.map(&:language)
#languages << 'en' if languages.length < 1

File.umask(0002)

begin
  Dir.chdir(@output_dir)
rescue Errno::ENOENT
  File.makedirs(@output_dir)
  Dir.chdir(@output_dir)
end

class String
  def esc
    return self.gsub(/'/, '\\\\\'')
  end
  def php
    return "'" + self.esc + "'"
  end
  def namify
    r = self.downcase
    [
      ['-', /-/],
      ['.', /\./],
      [' ', /\s+/]
    ].each do |sep, re|
      a = []
      r.split(re).each do |w|
        z = ''
        w.chars.each_with_index{|c,i| c=c.upcase if i==0; z << c}
        a << z
      end
      r = a.join(sep)
    end
    return r
  end
  def shortnamify
    bits = self.split(/\s+/)
    return bits[0..-2].map{|x| x[0..0].upcase + "."}.join('') + bits[-1].capitalize
  end
  def shorttrack
    return self.gsub(/\s+(track|devroom)$/i, '')
  end
  def urlify
    return URI.escape(self.downcase.gsub(/[\.&\?\+\*\/]/, '').gsub(/\s+/, '_').gsub(/'/, '_')).gsub(/%C3%AB/u, 'e').gsub(/%E4/u, 'a').gsub(/%C3%EA/u, 'a').gsub(/%AB/u, 'e').gsub(/%C3%98/u, 'O').gsub(/%C3%A5/u, 'a').gsub(/%C3%A9/u, 'e').gsub(/%C3%B8/u, 'oe').gsub(/%C5%A1/u, 's').gsub(/%C3%A6/u, 'ae').gsub(/%C3%B6/u, 'oe').gsub(/%C3%A8/u, 'e').gsub(/%C3%BC/u, 'ue').gsub(/%C3%A4/u, 'ae').gsub(/%C3%AA/u, 'e').gsub(/%C3%AC/u, 'i').gsub(/%C3%AD/u, 'i').gsub(/%C3%A7/u, 'c').gsub(/%C3%9F/u, 'ss').gsub(/'/, '').gsub(/%C3%A1/u, 'a').gsub(/%C3%B1/u, 'n').gsub(/%C3%BD/u, 'y').gsub(/%C3%B3/u, 'o').gsub(/%C3%BA/u, 'u').gsub(/%C3%AF/u, 'i')
  end
  def sqlify
    return "'" + self.gsub(/'/, "''").gsub(/\\/, '\&\&') + "'"
  end
  def nl2br
    return self.gsub(/\n/, "<br/>\n")
  end
end

def h(str)
  return str
end

def mobile_event(x, event, with_speakers, with_room)
  x.li do
    x.span("#{event.start_time.strftime("%H:%M")}-#{(event.start_time+event.duration).strftime("%H:%M")}", {:class=>"time"})
    x.span(" (#{event.conference_room})", {:class=>"room"}) if with_room
    x.br
    x.a(event.title, {:href=>"#{@mobile_base_url}event/#{event.slug.urlify}",:class=>"title"})
    speakers = (@event_speakers[event.event_id] or [])
    if with_speakers and not speakers.empty? then
      x.br
      x << speakers.collect{|s| s.name.shortnamify}.join(", ")
    end #if
  end #li
end #_event

def load_room_image(room)
  file = File.open(@template_prefix + "rooms/#{room}.png", "rb")
  content = file.read
  file.close
  return "data:image/png;base64," + Base64.encode64(content)
end

def load_person_image(person_id, size)
  img = Person_image.select({:person_id=>person_id})
  return nil if img.nil? or img.empty?
  img = img[0]
  return "data:#{img.mime_type};base64," + Base64.encode64(resize_image(img.image, size, img.mime_type))
end

def write_file( filename, content )
  file = File.open( filename , File::CREAT | File::WRONLY | File::TRUNC )
  file.write( content )
  file.close
end

def sort_event_by_room_affinity(e1, e2)
  a = []
  if e1.conference_room_id == e2.conference_room_id
    a << 1
  else
    a << 0
  end
  a << e1.start_datetime
  a << e1.duration
  return a
end

def event_is_upcoming_to(e1, e2, limit=15.minutes)
  (e2.end_datetime .. (e2.end_datetime + limit)).include? e1.start_datetime
end

def event_next_in_room(e1, e2)
  e1.conference_room_id == e2.conference_room_id and e1.start_datetime.day == e2.end_datetime.day and e1.start_datetime >= e2.end_datetime
end

def event_sametime(e1, e2)
  # discard e2 that starts right after e1, they're picked up by event_is_upcoming_to
  if e1.start_datetime == e2.end_datetime then
    return false
  end
  if e2.start_datetime <= e1.start_datetime and e2.end_datetime >= e1.start_datetime then
    # e2 starts before or at the same time as e1
    # AND
    # e2 ends after or at the same time as e1
    return true
  end
  if e2.start_datetime >= e1.start_datetime and e2.start_datetime < e1.end_datetime then
    # e2 starts after e1
    # AND
    # e2 ends before e1
    return true
  end
  return false
end

@speaker_map = {}
@speaker_images = {}
def speaker_has_image(id)
  return @speaker_images.has_key? id
end
def speaker_image(id, size)
  raise "No @speaker_images entry for speaker id #{id}" unless speaker_has_image(id)
  raise "No @speaker_map entry for speaker id #{id}" unless @speaker_map.has_key? id
  i = @speaker_images[id]
  s = @speaker_map[id]
  return "images/speaker/#{s.name.urlify}-#{size}x#{size}.#{mime_to_ext(i.mime_type)}"
end

def url_for(url)
  url[:controller] ||= 'schedule'
  url[:language] ||= 'en'
  target = case url[:controller]
    when 'schedule' then
      case url[:action]
        when :index then ""
        when :day then "day/#{url[:id].downcase}"
        when :event then "event/#{url[:slug].urlify}"
        when :event_attachment then "attachments/#{url[:event_attachment_id]}#{url[:filename].to_s.length > 0 ? '_' + url[:filename] : ''}"
        when :events then "events.#{url[:language]}.html"
        when :track_event then "track/#{url[:track]}/#{url[:id]}.#{url[:language]}.html"
        when :track_events then "track/#{url[:track]}/index.#{url[:language]}.html"
        when :track then "track/#{url[:track].urlify}"
        when :track_ical then "track/#{url[:track].urlify}.ics"
        when :track_xcal then "track/#{url[:track].urlify}.xcs"
        when :room then "room/#{url[:room].urlify}"
        when :speaker then "speaker/#{url[:name].urlify}"
        when :speakers then "speakers.#{url[:language]}.html"
        when :speaker_image then speaker_image(url[:id], url[:size])
        when :css then 
          "style.css"
        end
    when 'image' then
      case url[:action]
        when :conference then "images/conference-#{url[:size]}.#{url[:extension]}"
        when :event then "images/event-#{url[:id]}-#{url[:size]}.#{url[:extension]}"
        when :person then "images/person-#{url[:id]}-#{url[:size]}.#{url[:extension]}"
      end
    end
  target
end

@current_language = @lang
@params = {}
def local( tag, arguments = {} )
  Localizer.lookup( tag.to_s, @current_language, arguments )
end

def mime_to_ext(mime)
  ext = case mime
        when "image/png" then "png"
        when "image/jpeg" then "jpg"
        else raise "Unsupported MIME type #{mime}"
        end
  return ext
end

def resize_image(image, size, mime)
  format = case mime
           when "image/png" then "PNG"
           when "image/jpeg" then "JPEG"
           else raise "Unsupported MIME type #{mime}"
           end
  resized = Magick::Image.from_blob(image)[0]
  #resized.x_resolution = 72
  #resized.y_resolution = 72
  resized.format = format if format
  resized.resize_to_fit!(size, size).strip!.to_blob
end

current_url = {:controller=>'schedule',:action=>:index,:language=>'en',:conference_id=>@conference.conference_id}

@template_prefix = @here + '/' + File.dirname(__FILE__) + '/../app/views/fosdem/'

def mkfile(f)
  o = @output_dir + '/' + f
  d = File.dirname(o)
  File.makedirs(d) #unless File.directory? d
  puts "Rendering #{o}"
  yield File.open(o, File::CREAT|File::WRONLY|File::TRUNC)
end

def rxml(template_filename, wrap_with_div=true)
  f = @template_prefix + template_filename + '.rxml'
  template_content = File.new(f, "r").read
  xml = Builder::XmlMarkup.new(:indent => 2)
  params = @params
  if wrap_with_div then
    xml.div(:id=>'schedule') do
      eval(template_content, binding(), f, 1)
    end
  else
    eval(template_content, binding(), f, 1)
  end
end

def rxmlfile(template_filename, output_filename, wrap_with_div=true)
  o = @output_dir + '/' + output_filename
  o += '.html' unless o =~ /\./
  d = File.dirname(o)
  File.makedirs(d) #unless File.directory? d
  puts "Rendering #{o}"
  buffer = rxml(template_filename, wrap_with_div)
  out = File.open(o, File::CREAT|File::WRONLY|File::TRUNC)
  out.write(buffer)
  out.close
end

def is_main_track(t)
  raise "t is nil" if t.nil?
  if (t.is_a? String) then
    return (t =~ /^keynotes$/i or t =~ /track$/i) ? true : false
  else
    raise "#{t.class} (#{t.inspect}) does not have a conference_track method" unless t.respond_to?(:conference_track)
    return is_main_track(t.conference_track)
  end
end

def is_devroom_track(t)
  raise "t is nil" if t.nil?
  if (t.is_a? String) then
    return (t =~ /devroom$/i) ? true : false
  else
    raise "#{t.class} (#{t.inspect}) does not have a conference_track method" unless t.respond_to?(:conference_track)
    return is_devroom_track(t.conference_track)
  end
end

def is_lightning_talk(t)
  raise "t is nil" if t.nil?
  if (t.is_a? String) then
    return (t =~ /^lightning\s+talks?$/i) ? true : false
  else
    raise "#{t.class} (#{t.inspect}) does not have a conference_track method" unless t.respond_to?(:conference_track)
    return is_lightning_talk(t.conference_track)
  end
end

def is_cert_exam(t)
  raise "t is nil" if t.nil?
  if (t.is_a? String) then
    return (t =~ /^certifications?$/i) ? true : false
  else
    raise "#{t.class} (#{t.inspect}) does not have a conference_track method" unless t.respond_to?(:conference_track)
    return is_cert_exam(t.conference_track)
  end
end


#################################################################################################################

# make some output directories
['images', 'images/speaker', 'event', 'speaker', 'track', 'attachments', 'room', 'day', 'includes'].each do |d|
  File.makedirs(d)
end

@tracks = []
@track_map = {}
@main_tracks = []
@devroom_tracks = []
@lightning_talks = []
@cert_exams = []
begin
  tracks = Conference_track.select({:conference_id=>@conference.conference_id})
  tracks.each do |t|
    @tracks << t
    @track_map[t.conference_track_id] = t
    @main_tracks << t if is_main_track(t)
    @devroom_tracks << t if is_devroom_track(t)
  end
end

@event_person_id_map = {}
@event_speakers = {}
@speakers = []
begin
  ep = View_event_person.select({:translated=>@lang, :conference_id=>@conference.conference_id, :event_role=>'speaker'})
  ep.each do |x|
    @event_person_id_map[x.event_id.to_i] = [] unless @event_person_id_map.has_key? x.event_id
    @event_person_id_map[x.event_id.to_i] << x.person_id.to_i
  end
  @event_person_id_map.each do |eid,pids|
    @event_speakers[eid] = [] unless @event_speakers.has_key? eid
    pids.each do |pid|
      p = View_schedule_person_fosdem.select({:person_id=>pid, :event_role=>'speaker'})
      p.each do |person|
        @event_speakers[eid] << person
        if not @speaker_map.has_key? person.person_id then
          @speakers << person
          @speaker_map[person.person_id] = person
        end
      end
      #raise "Failed to find view_event_person for :person_id = #{pid}" unless count > 0
    end
  end
  @event_speakers.each do |eid,speakers|
    speakers.uniq!
  end
end
@speakers.uniq!

@events = []
@event_map = {}
@speaker_events = {}
@events_by_track = {}
begin
  events = View_schedule_event_fosdem.select({:translated=>@lang, :conference_id=>@conference.conference_id},{:order=>[:title,:subtitle]})
  events.each do |e|
    @events << e
    @event_map[e.event_id] = e
    if @event_speakers.has_key? e.event_id then
      @event_speakers[e.event_id].each do |person|
        @speaker_events[person.person_id] = [] unless @speaker_events.has_key? person.person_id
        @speaker_events[person.person_id] << e
      end
    end
    @events_by_track[e.conference_track_id] = [] unless @events_by_track.has_key? e.conference_track_id
    @events_by_track[e.conference_track_id] << e
    @lightning_talks << e if is_lightning_talk(e)
    @cert_exams << e if is_cert_exam(e)
  end
end

def track_sort_base(track)
  -(-track.rank + case track.conference_track
         when /^keynote/i then 10000
         when /track$/i then 1000
         when /^lightning/i then 500
         when /devroom$/i then 100
         else 0
         end)
end

@tracks = []
@track_map = {}
begin
  tracks = Conference_track.select({:conference_id=>@conference.conference_id},{:order=>:rank})
  tracks.each do |t|
    @tracks << t
    @track_map[t.conference_track_id] = t
  end
end

@rooms = []
@room_map = {}
begin
  rooms = Conference_room.select({:conference_id=>@conference.conference_id}, {:public=>true})
  rooms.each do |room|
    @rooms << room
    @room_map[room.conference_room_id] = room
  end
end

@room_events = {}
begin
  @events.each do |e|
    rid = e.conference_room_id
    next if rid.nil?
    @room_events[rid] = [] unless @room_events.has_key? rid
    @room_events[rid] << e
  end
  @room_events.each do |rid,events|
    events.uniq!
  end
end

@track_rooms = {}
begin
  @events.each do |e|
    rid = e.conference_room_id
    r = @room_map[rid]
    tid = e.conference_track_id
    @track_rooms[tid] = [] unless @track_rooms.has_key? tid
    @track_rooms[tid] << r
  end
  @track_rooms.each do |tid,rooms|
    rooms.uniq!
  end
end

@date_tracks = {}
@date_track_name = {} # official name of the day
begin
  @events.group_by{|e| [e.start_datetime.strftime("%Y-%m-%d"), e.conference_track_id]}.each do |(date,tid), events|
    if not @date_tracks.has_key? date
      @date_tracks[date] = []
      @date_track_name[date] = events[0].start_datetime.strftime('%A %F')
    end
    @date_tracks[date] << tid
  end
end


def ical(calname, filename, events)
  eol = $\
  $\ = "\r\n"
  o = @output_dir + '/' + filename
  puts "Rendering #{o}"
  File.open(o, File::CREAT|File::WRONLY|File::TRUNC) do |f|
    # use print here and not puts, as ics files MUST be CRLF (as of RFC2445) and
    # $\ only affects print, and not puts
    f.print "BEGIN:VCALENDAR"
    f.print "VERSION:2.0"
    f.print "PRODID:-//Pentabarf//Schedule 0.3//EN"
    f.print "CALSCALE:GREGORIAN"
    f.print "METHOD:PUBLISH"
    f.print "X-WR-CALDESC;VALUE=TEXT:Schedule of sessions for #{calname}"
    f.print "X-WR-CALNAME;VALUE=TEXT:#{calname} Schedule"
    f.print "X-WR-TIMEZONE;VALUE=TEXT:#{@timezone}"
    events.sort_by{|e| e.start_datetime}.each do |event|
      f.print "BEGIN:VEVENT"
      f.print "METHOD:PUBLISH"
      f.print "UID:#{event.event_id}@#{@conference.acronym}@fosdem.org"
      f.print "TZID:#{@timezone.gsub('/', '-')}"
      f.print "DTSTART:#{event.start_datetime.strftime('%Y%m%dT%H%M%S')}"
      f.print "DTEND:#{event.end_datetime.strftime('%Y%m%dT%H%M%S')}"
      # having both DTEND and DURATION breaks Apple's iCal, go figure
      #f.print "DURATION:PT#{event.duration.hour.to_s + 'H'}"
      f.print "SUMMARY:#{event.title}"
      if event.abstract.to_s.length > 0 then
        f.print "DESCRIPTION: #{event.abstract.to_s.gsub(/[\r\n]/,'')}"
      end
      f.print "CLASS:PUBLIC"
      f.print "STATUS:CONFIRMED"
      f.print "CATEGORIES:#{event.conference_track}"
      f.print "URL:#{@conference.export_base_url}event/#{event.slug.urlify}"
      f.print "LOCATION:#{event.conference_room}"
      (@event_speakers[event.event_id] or []).each do |speaker|
        f.print "ATTENDEE;ROLE=REQ-PARTICIPANT;CUTYPE=INDIVIDUAL;CN=\"#{speaker.name.namify}\":invalid:nomail"
      end
      f.print "END:VEVENT"
    end #event
    f.print "END:VCALENDAR"
  end #f
  $\ = eol
end #ical

#################################################################################################

if @export_sql then
  mkfile 'schedule.sql' do |f|
    f.puts """
DROP TABLE IF EXISTS schedule;
CREATE TABLE schedule (
  t           ENUM('event', 'speaker') NOT NULL,
  url         VARCHAR(1024) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,
  title       TEXT CHARACTER SET utf8 NOT NULL,
  subtitle    TEXT CHARACTER SET utf8 NULL,
  abstract    TEXT CHARACTER SET utf8 NULL,
  description TEXT CHARACTER SET utf8 NULL,
  FULLTEXT (title,subtitle,abstract,description)
) TYPE=MyISAM;

"""

    def s(o)
      return "NULL" if o.nil? or o.empty?
      return o.sqlify.strip
    end #s

    @events.each do |event|
      f.puts "INSERT INTO schedule(t,url,title,subtitle,abstract,description) VALUES('event', #{event.slug.urlify.sqlify}, #{event.title.sqlify}, #{s(event.subtitle)}, #{s(event.abstract)}, #{s(event.description)});"
    end #@events
    f.puts
    @speakers.each do |speaker|
      f.puts "INSERT INTO schedule(t,url,title,subtitle,abstract,description) VALUES('speaker', #{speaker.name.urlify.sqlify}, #{speaker.name.namify.sqlify}, NULL, #{s(speaker.abstract)}, #{s(speaker.description)});"
    end #@speakers
  end #f
  exit 0 if ENV.has_key? 'ONLYSQL'
end

begin
  rxmlfile('mobile', 'mobile', false)
  @events.each do |event|
    @event = event
    rxmlfile('event-mobile', "mobile/event/#{event.slug.urlify}", false)
  end
  @speakers.each do |speaker|
    @speaker = speaker
    rxmlfile('speaker-mobile', "mobile/speaker/#{speaker.name.urlify}", false)
  end
end
exit 0 if ENV.has_key? 'ONLYMOBILE'

begin
  puts "Rendering person pictures"
  images = Person_image.select({})
  images.each do |img|
    next unless img.public
    next unless @speaker_map.has_key? img.person_id
    speaker = @speaker_map[img.person_id]
    @speaker_images[img.person_id] = img
    IMAGE_SIZES.each do |size|
      ext = mime_to_ext(img.mime_type)
      f = "images/speaker/#{speaker.name.urlify}-#{size}x#{size}.#{ext}"
      #puts "rendering image #{f}"
      write_file(f, resize_image(img.image, size, img.mime_type)) #'png'))
    end
  end
end

begin
  rxmlfile('xml', "schedule.#{@lang}.xml", false)
  begin
    @xcal_events = @events
    @xcal_cal = "#{@conference.acronym}"
    rxmlfile('xcal', "schedule.#{@lang}.xcs", false)
  end
  ical("#{@conference.acronym}", "schedule.#{@lang}.ics", @events)
  @tracks.each do |track|
    track_events = (@events_by_track[track.conference_track_id] or [])
    ical("#{@conference.acronym} (#{track.conference_track})", "track/#{track.conference_track.urlify}.ics", track_events)
    @xcal_events = track_events
    @xcal_cal = "#{@conference.acronym} (#{track.conference_track})"
    rxmlfile('xcal', "track/#{track.conference_track.urlify}.xcs", false)
  end

  @urlprefix = ''
  rxmlfile('days', 'days')
  begin
    @urlprefix = '../'
    [1, 2].each do |@day|
      rxmlfile('days', "day/#{@day}")
    end
  end
  rxmlfile('rooms', 'rooms')
  @speakers_per_row = 4
  rxmlfile('allspeakers', 'allspeakers')
  rxmlfile('maintracks', 'maintracks')
  rxmlfile('tracks', 'tracks')
  rxmlfile('devrooms', 'devrooms')
  rxmlfile('events', 'events')
end

begin
  @speakers.each do |speaker|
    @speaker = speaker
    rxmlfile('speaker', "speaker/#{speaker.name.urlify}")
  end
end

begin
  @events.each do |event|
    @event = event
    rxmlfile('event', "event/#{event.slug.urlify}")
  end
end

begin
  @no_speaker_image = true
  @tracks.each do |track|
    @track = track
    @track_events = (@events_by_track[track.conference_track_id] or [])
    rxmlfile('track', "track/#{@track.conference_track.urlify}")
  end
end

begin
  @rooms.each do |room|
    @room = room
    rxmlfile('room', "room/#{room.conference_room.urlify}")
  end
end

mkfile 'includes/maps.php' do |f|
  f.puts "<?php"
  f.puts '$PENTABARF_EVENT_TITLE_BY_URL = array();'
  f.puts '$PENTABARF_EVENT_ID_BY_URL    = array();'
  f.puts '$PENTABARF_PERSON_NAME_BY_URL = array();'
  f.puts '$PENTABARF_PERSON_ID_BY_URL   = array();'
  f.puts '$PENTABARF_TRACK_NAME_BY_URL  = array();'
  f.puts '$PENTABARF_ROOM_NAME_BY_URL   = array();'
  f.puts '$PENTABARF_ROOM_GEO_BY_URL    = array();'
  f.puts '$PENTABARF_DAY_NAME_BY_ID     = array();'
  f.puts '$PENTABARF_DAY_NAME_BY_URL    = array();'
  f.puts '$PENTABARF_DAY_ID_BY_URL      = array();'
  f.puts

  @events.each do |e|
    raise "slug is nil for event #{e.title} (#{e.event_id})" if e.slug.nil?
    f.puts "$PENTABARF_EVENT_TITLE_BY_URL[#{e.slug.urlify.php}] = #{e.title.php};"
    f.puts "$PENTABARF_EVENT_ID_BY_URL[#{e.slug.urlify.php}] = #{e.event_id};"
  end
  f.puts
  @speakers.each do |s|
    f.puts "$PENTABARF_PERSON_NAME_BY_URL[#{s.name.urlify.php}] = #{s.name.namify.php};"
    f.puts "$PENTABARF_PERSON_ID_BY_URL[#{s.name.urlify.php}] = #{s.person_id};"
  end
  f.puts
  @tracks.each do |t|
    f.puts "$PENTABARF_TRACK_NAME_BY_URL[#{t.conference_track.urlify.php}] = #{t.conference_track.php};"
  end
  @rooms.each do |r|
    f.puts "$PENTABARF_ROOM_NAME_BY_URL[#{r.conference_room.urlify.php}] = #{r.conference_room.php};"
  end
  @rooms.each do |r|
    geo = @room_geo[r.conference_room.urlify]
    unless geo.nil? then
      f.puts "$PENTABARF_ROOM_GEO_BY_URL[#{r.conference_room.urlify.php}] = array(#{geo[0].php}, #{geo[1].php});"
    end
  end #rooms
  begin
    first_day = @events.map{|e| e.start_datetime.to_date}.min
    @events.map{|e| e.start_datetime.to_date}.uniq.sort.each do |d|
      id = (d - first_day) + 1
      f.puts "$PENTABARF_DAY_NAME_BY_ID[#{id}] = #{d.strftime("%A %F").php};"
      f.puts "$PENTABARF_DAY_NAME_BY_URL[#{d.strftime("%a").downcase.php}] = #{d.strftime("%A %F").php};"
      f.puts "$PENTABARF_DAY_ID_BY_URL[#{d.strftime("%a").downcase.php}] = #{id};"
    end
  end
end #f

exit 0

