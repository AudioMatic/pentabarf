#!/usr/bin/env ruby
ENV['RAILS_ENV'] = 'production'
require File.dirname(__FILE__) + '/../config/boot'
require File.dirname(__FILE__) + '/../config/environment'
require 'builder'
require 'schedule_helper'
include ScheduleHelper
include ApplicationHelper
require 'ftools'
require 'set'
require 'RMagick'
require 'base64'
require 'progressbar'

@lang = 'en'
@language = 'English'
@here = Dir.pwd
@timezone = 'Europe/Brussels'
output_dir_base = "#{@here}/tmp/fosdem-export"
@grid_max_columns = 7
@grid_max_title_length = 25
@mobile_base_url = 'https://m.fosdem.org/'
@only_rooms = []

export_odf = false
export_sql = false
export_mobile = export_schedule = export_xml = export_xcal = export_php = true

if ENV.has_key? 'OUTPUT_DIR' then
  output_dir_base = ENV['OUTPUT_DIR']
end
if ENV.has_key? 'ONLY_XML' then
  export_mobile = export_schedule = export_xcal = export_php = false
end
if ENV.has_key? 'ONLY_ROOMS' then
  @only_rooms = ENV['ONLY_ROOMS'].split(/\s+/)
end

# keep it here until it's stored in Pentabarf:
# (hash values are [ lat, long ])
# use this: http://www.europe-camping-guide.com/get-longitude-latitude-google-maps/
@room_geo = {
  'h2214'      => [ '50.81290582134759', '4.3803611397743225' ],
  'janson'     => [ '50.81325663668648', '4.37966912984848' ],
  'chavanne'   => [ '50.81254991903593', '4.382069706916809' ],
  'ferrer'     => [ '50.812883789378475', '4.380328953266144' ],
  'lameere'    => [ '50.812039787659984', '4.382337927818298' ],
  'h3227'      => [ '50.81291937947728', '4.380280673503876' ],
  'h1301'      => [ '50.81264313180825', '4.379730820655823' ],
  'h1302'      => [ '50.812687195963115', '4.379897117614746' ],
  'h1308'      => [ '50.81273295484919', '4.380033910274506' ],
  'h1309'      => [ '50.81276854506295', '4.380189478397369' ],
  'h2213'      => [ '50.81287362077382', '4.380377233028412' ],
  'guillissen' => [ '50.81176522959664', '4.382879734039307' ],
  'ua2114'     => [ '50.81176522959664', '4.383099675178528' ],
  'aw1105'     => [ '50.81203809286208', '4.380693733692169' ],
  'aw1115'     => [ '50.81224485775319', '4.3805475533008575' ],
  'aw1117'     => [ '50.81227112699761', '4.380617290735245' ],
  'aw1120'     => [ '50.812303327986754', '4.380767494440079' ],
  'aw1121'     => [ '50.81227960094425', '4.3808358907699585' ],
  'aw1124'     => [ '50.812201640577015', '4.38085600733757' ],
  'aw1125'     => [ '50.81213639103922', '4.380936473608017' ],
  'aw1126'     => [ '50.812161812947906', '4.380939155817032' ],
}

@c = nil
case ARGV.length
when 1
  @c = ARGV[0]
when 0
  if ENV.has_key? 'FOSDEM_CONF' then
    @c = ENV['FOSDEM_CONF']
  else
    puts "Must specify the acronym of the conference as first parameter !"
    puts "Here is the list of available acronyms:"
    Conference.select.sort_by{|r| r.acronym}.each do |r|
      puts "\t#{r.acronym}"
    end
    puts "Please run this script again and specify the acronym of the conference"
    puts "you would like to export as first parameter."
    exit 1
  end
else
  raise "too many parameters, only supports one (the acronym of the conference)"
end

@conference = Conference.select_single(:acronym=>@c)
@confname = @conference.title
@output_dir = "#{output_dir_base}/#{@conference.acronym}"

IMAGE_SIZES = [22,32,48,128]

File.umask(0002)

begin
  Dir.chdir(@output_dir)
rescue Errno::ENOENT
  File.makedirs(@output_dir)
  Dir.chdir(@output_dir)
end

class String
  def esc
    return self.gsub(/'/, '\\\\\'')
  end
  def php
    return "'" + self.esc + "'"
  end
  def namify
    r = self.downcase
    [
      ['-', /-/],
      ['.', /\./],
      [' ', /\s+/]
    ].each do |sep, re|
      a = []
      r.split(re).each do |w|
        z = ''
        w.chars.each_with_index{|c,i| c=c.upcase if i==0; z << c}
        a << z
      end
      r = a.join(sep)
    end
    return r
  end
  def shortnamify
    bits = self.split(/\s+/)
    return bits[0..-2].map{|x| x[0..0].upcase + "."}.join('') + bits[-1].capitalize
  end
  def shorttrack
    return self.gsub(/\s+(track|devroom)$/i, '')
  end
  def urlify
    return URI.escape(self.downcase.gsub(/[\.&\?\+\*\/]/, '').gsub(/\s+/, '_').gsub(/'/, '_')).gsub(/%C3%AB/u, 'e').gsub(/%E4/u, 'a').gsub(/%C3%EA/u, 'a').gsub(/%AB/u, 'e').gsub(/%C3%98/u, 'O').gsub(/%C3%A5/u, 'a').gsub(/%C3%A9/u, 'e').gsub(/%C3%B8/u, 'oe').gsub(/%C5%A1/u, 's').gsub(/%C3%A6/u, 'ae').gsub(/%C3%B6/u, 'oe').gsub(/%C3%A8/u, 'e').gsub(/%C3%BC/u, 'ue').gsub(/%C3%A4/u, 'ae').gsub(/%C3%AA/u, 'e').gsub(/%C3%AC/u, 'i').gsub(/%C3%AD/u, 'i').gsub(/%C3%A7/u, 'c').gsub(/%C3%9F/u, 'ss').gsub(/'/, '').gsub(/%C3%A1/u, 'a').gsub(/%C3%B1/u, 'n').gsub(/%C3%BD/u, 'y').gsub(/%C3%B3/u, 'o').gsub(/%C3%BA/u, 'u').gsub(/%C3%AF/u, 'i').gsub(/%C5%99/u, 'r').gsub(/%C4%9B/u, 'e').gsub(/%C3%96/u, 'U').gsub(/%C4%87/u, 'c').gsub(/%C3%B4/u, 'o').gsub(/%C3%86/u, 'AE').gsub(/%C3%B0/u, 'd')
  end
  def sqlify
    return "'" + self.gsub(/'/, "''").gsub(/\\/, '\&\&') + "'"
  end
  def nl2br
    return self.gsub(/\n/, "<br/>\n")
  end
end

class Array
  def uniq_by(&blk)
    transforms = {}
    select do |el|
      t = blk[el]
      should_keep = !transforms[t]
      transforms[t] = true
      should_keep
    end
  end
end

def h(str)
  return str
end

def mobile_event(x, event, with_speakers, with_room, with_track)
  raise "event without a slug: #{event.event_id}" if event.slug.nil?

  x.li do
    x.span("#{event.start_time.strftime("%H:%M")}-#{(event.start_time+event.duration).strftime("%H:%M")}", {:class=>"time"})
    x.span(" (#{event.conference_room})", {:class=>"room"}) if with_room
    x.br
    x.a(event.title, {:href=>"#{@mobile_base_url}event/#{event.slug.urlify}",:class=>"title"})
    speakers = (@event_speakers[event.event_id] or []).uniq
    if with_track then
      x.br
      x << event.conference_track
    end
    if with_speakers and not speakers.empty? then
      x.br
      x << speakers.select{|s| not s.name =~ /fosdem|staff/i}.collect{|s| s.name.shortnamify}.join(", ")
    end #if
  end #li
end #_event

def load_room_image(room)
  begin
    file = File.open(@template_prefix + "rooms/#{room}.png", "rb")
    content = file.read
    file.close
    return "data:image/png;base64," + Base64.encode64(content)
  rescue
    return nil
  end
end

def load_person_image(person_id, size)
  img = Person_image.select({:person_id=>person_id})
  return nil if img.nil? or img.empty?
  img = img[0]
  return nil if img.image.length < 1
  begin
    return "data:#{img.mime_type};base64," + Base64.encode64(resize_image(img.image, size, img.mime_type))
  rescue => e
    puts "WARNING: failed to load person image for person_id=#{person_id}: #{e.message}"
    return nil
  end
end

def write_file( filename, content )
  file = File.open( filename , File::CREAT | File::WRONLY | File::TRUNC )
  file.write( content )
  file.close
end

def sort_event_by_room_affinity(e1, e2)
  a = []
  if e1.conference_room_id == e2.conference_room_id
    a << 1
  else
    a << 0
  end
  a << e1.start_datetime
  a << e1.duration
  return a
end

def event_is_upcoming_to(e1, e2, limit=15.minutes)
  (e2.end_datetime .. (e2.end_datetime + limit)).include? e1.start_datetime
end

def event_next_in_room(e1, e2)
  e1.conference_room_id == e2.conference_room_id and e1.start_datetime.day == e2.end_datetime.day and e1.start_datetime >= e2.end_datetime
end

def event_sametime(e1, e2)
  # discard e2 that starts right after e1, they're picked up by event_is_upcoming_to
  if e1.start_datetime == e2.end_datetime then
    return false
  end
  if e2.start_datetime <= e1.start_datetime and e2.end_datetime >= e1.start_datetime then
    # e2 starts before or at the same time as e1
    # AND
    # e2 ends after or at the same time as e1
    return true
  end
  if e2.start_datetime >= e1.start_datetime and e2.start_datetime < e1.end_datetime then
    # e2 starts after e1
    # AND
    # e2 ends before e1
    return true
  end
  return false
end

@speaker_map = {}
@speaker_images = {}
def speaker_has_image(id)
  return @speaker_images.has_key? id
end
def speaker_image(id, size)
  raise "No @speaker_images entry for speaker id #{id}" unless speaker_has_image(id)
  raise "No @speaker_map entry for speaker id #{id}" unless @speaker_map.has_key? id
  i = @speaker_images[id]
  s = @speaker_map[id]
  return "images/speaker/#{s.name.urlify}-#{size}x#{size}.#{mime_to_ext(i.mime_type)}"
end

def url_for(url)
  url[:controller] ||= 'schedule'
  url[:language] ||= 'en'
  target = case url[:controller]
    when 'schedule' then
      case url[:action]
        when :index then ""
        when :day then "day/#{url[:id].downcase}"
        when :event then "event/#{url[:slug].urlify}"
        when :event_attachment then "attachments/#{url[:event_attachment_id]}#{url[:filename].to_s.length > 0 ? '_' + url[:filename] : ''}"
        when :events then "events.#{url[:language]}.html"
        when :track_event then "track/#{url[:track]}/#{url[:id]}.#{url[:language]}.html"
        when :track_events then "track/#{url[:track]}/index.#{url[:language]}.html"
        when :track then "track/#{url[:track].urlify}"
        when :track_ical then "track/#{url[:track].urlify}.ics"
        when :track_xcal then "track/#{url[:track].urlify}.xcs"
        when :room then "room/#{url[:room].urlify}"
        when :speaker then "speaker/#{url[:name].urlify}"
        when :speakers then "speakers.#{url[:language]}.html"
        when :speaker_image then speaker_image(url[:id], url[:size])
        when :css then 
          "style.css"
        end
    when 'image' then
      case url[:action]
        when :conference then "images/conference-#{url[:size]}.#{url[:extension]}"
        when :event then "images/event-#{url[:id]}-#{url[:size]}.#{url[:extension]}"
        when :person then "images/person-#{url[:id]}-#{url[:size]}.#{url[:extension]}"
      end
    end
  target
end

@current_language = @lang
@params = {}
def local( tag, arguments = {} )
  Localizer.lookup( tag.to_s, @current_language, arguments )
end

def mime_to_ext(mime)
  ext = case mime
        when "image/png" then "png"
        when "image/jpeg" then "jpg"
        when "image/gif" then "gif"
        else raise "Unsupported MIME type #{mime}"
        end
  return ext
end

def resize_image(image, size, mime)
  format = case mime
           when "image/png" then "PNG"
           when "image/jpeg" then "JPEG"
           when "image/gif" then "GIF"
           else raise "Unsupported MIME type #{mime}"
           end
  resized = Magick::Image.from_blob(image)[0]
  #resized.x_resolution = 72
  #resized.y_resolution = 72
  resized.format = format if format
  resized.resize_to_fit!(size, size).strip!.to_blob
end

current_url = {:controller=>'schedule',:action=>:index,:language=>'en',:conference_id=>@conference.conference_id}

@template_prefix = @here + '/' + File.dirname(__FILE__) + '/../app/views/fosdem/'

def mkfile(f)
  o = @output_dir + '/' + f
  d = File.dirname(o)
  File.makedirs(d) #unless File.directory? d
  # puts "Rendering #{o}"
  yield File.open(o, File::CREAT|File::WRONLY|File::TRUNC)
end

def rxml(template_filename, wrap_with_div=true)
  f = @template_prefix + template_filename + '.rxml'
  template_content = File.new(f, "r").read
  xml = Builder::XmlMarkup.new(:indent => 2)
  params = @params
  if wrap_with_div then
    xml.div(:id=>'schedule') do
      eval(template_content, binding(), f, 1)
    end
  else
    eval(template_content, binding(), f, 1)
  end
end

def rxmlfile(template_filename, output_filename, wrap_with_div=true)
  o = @output_dir + '/' + output_filename
  o += '.html' unless o =~ /\./
  d = File.dirname(o)
  File.makedirs(d) #unless File.directory? d
  # puts "Rendering #{o}"
  buffer = rxml(template_filename, wrap_with_div)
  out = File.open(o, File::CREAT|File::WRONLY|File::TRUNC)
  out.write(buffer)
  out.close
end

def is_main_track(t)
  raise "t is nil" if t.nil?
  if is_devroom_track(t) or is_lightning_talk(t) or is_cert_exam(t) then
    return false
  else
    return true
  end
  #if (t.is_a? String) then
  #  return (t =~ /^keynotes$/i or t =~ /track$/i) ? true : false
  #else
  #  raise "#{t.class} (#{t.inspect}) does not have a conference_track method" unless t.respond_to?(:conference_track)
  #  return is_main_track(t.conference_track)
  #end
end

def is_devroom_track(t)
  raise "t is nil" if t.nil?
  if (t.is_a? String) then
    return (t =~ /devroom$/i) ? true : false
  else
    raise "#{t.class} (#{t.inspect}) does not have a conference_track method" unless t.respond_to?(:conference_track)
    return is_devroom_track(t.conference_track)
  end
end

def is_lightning_talk(t)
  raise "t is nil" if t.nil?
  if (t.is_a? String) then
    return (t =~ /^lightning\s*talks?$/i) ? true : false
  else
    raise "#{t.class} (#{t.inspect}) does not have a conference_track method" unless t.respond_to?(:conference_track)
    return is_lightning_talk(t.conference_track)
  end
end

def is_cert_exam(t)
  raise "t is nil" if t.nil?
  if (t.is_a? String) then
    return (t =~ /^(certifications?|cacert)$/i) ? true : false
  else
    raise "#{t.class} (#{t.inspect}) does not have a conference_track method" unless t.respond_to?(:conference_track)
    return is_cert_exam(t.conference_track)
  end
end


#################################################################################################################

# make some output directories
['images', 'images/speaker', 'event', 'speaker', 'track', 'room', 'day', 'includes'].each do |d|
  File.makedirs(d)
end

total = 0

@tracks = []
@track_map = {}
@main_tracks = []
@devroom_tracks = []
@lightning_talks = []
@cert_exams = []
begin
  tracks = Conference_track.select({:conference_id=>@conference.conference_id})
  tracks.each do |t|
    @tracks << t
    @track_map[t.conference_track_id] = t
    @main_tracks << t if is_main_track(t)
    @devroom_tracks << t if is_devroom_track(t)
  end
  total += @tracks.length if export_schedule
  total += (@tracks.length * 2) if export_xcal
  total += @tracks.length if export_mobile
  total += @tracks.length if export_odf
end

@event_person_id_map = {}
@event_speakers = {}
@speakers = []
begin
  ep = View_event_person.select({
    :translated=>@lang,
    :conference_id=>@conference.conference_id,
    :event_role=>'speaker',
  })
    #:event_role_state=>'confirmed'
  ep.each do |x|
    @event_person_id_map[x.event_id.to_i] = [] unless @event_person_id_map.has_key? x.event_id
    @event_person_id_map[x.event_id.to_i] << x.person_id.to_i
  end
  @event_person_id_map.each do |eid,pids|
    @event_speakers[eid] = [] unless @event_speakers.has_key? eid
    pids.each do |pid|
      p = View_schedule_person_fosdem.select({:person_id=>pid, :event_role=>'speaker', :conference_id=>@conference.conference_id})
      #p = View_schedule_person.select({:person_id=>pid, :event_role=>'speaker', :conference_id=>@conference.conference_id})
      p.each do |person|
        #next if person.conference_person_id.nil?
        next unless person.event_role == 'speaker'
        @event_speakers[eid] << person
        if not @speaker_map.has_key? person.person_id then
          @speakers << person
          @speaker_map[person.person_id] = person
        end
      end
      #raise "Failed to find view_event_person for :person_id = #{pid}" unless count > 0
    end
  end
  @event_speakers.each do |eid,speakers|
    speakers.uniq!
  end
end
@speakers.uniq!
total += @speakers.length if export_schedule
total += @speakers.length if export_mobile

@events = []
@event_map = {}
@speaker_events = {}
@events_by_track = {}
begin
  events = View_schedule_event.select({
    :translated=>@lang,
    :conference_id=>@conference.conference_id,
  }, {
    :order=>[:title,:subtitle]
  })
  events.each do |e|
    @events << e
    @event_map[e.event_id] = e
    if @event_speakers.has_key? e.event_id then
      @event_speakers[e.event_id].each do |person|
        @speaker_events[person.person_id] = [] unless @speaker_events.has_key? person.person_id
        @speaker_events[person.person_id] << e
      end
    end
    @events_by_track[e.conference_track_id] = [] unless @events_by_track.has_key? e.conference_track_id
    @events_by_track[e.conference_track_id] << e
    @lightning_talks << e if is_lightning_talk(e)
    @cert_exams << e if is_cert_exam(e)
  end

  total += @events.length if export_schedule
  total += @events.length if export_mobile
end

# uniquify speaker_events
begin
  seu = {}
  @speaker_events.each_pair do |person_id, events|
    seu[person_id] = events.uniq_by{|e| e.event_id}
  end
  @speaker_events = seu
end

# uniquify event_speakers
begin
  esu = {}
  @event_speakers.each_pair do |event_id, speakers|
    esu[event_id] = speakers.uniq_by{|p| p.person_id}
  end
  @event_speakers = esu
end

speakers_with_events = @speakers.select{|s| @speaker_events.has_key? s.person_id }
@speakers = speakers_with_events
total += @speakers.length if export_schedule
total += @speakers.length if export_mobile

def track_sort_base(track)
  -(-track.rank + case track.conference_track
         when /^keynote/i then 10000
         when /track$/i then 1000
         when /^lightning/i then 500
         when /devroom$/i then 100
         else 0
         end)
end

@tracks = []
@track_map = {}
begin
  tracks = Conference_track.select({:conference_id=>@conference.conference_id},{:order=>:rank})
  tracks.each do |t|
    @tracks << t
    @track_map[t.conference_track_id] = t
  end
end

@rooms = []
@room_map = {}
begin
  rooms = Conference_room.select({:conference_id=>@conference.conference_id}, {:public=>true})
  rooms.each do |room|
    @rooms << room
    @room_map[room.conference_room_id] = room
  end
  total += @rooms.length if export_schedule
  total += @rooms.length if export_mobile
end

@room_events = {}
begin
  @events.each do |e|
    rid = e.conference_room_id
    next if rid.nil?
    @room_events[rid] = [] unless @room_events.has_key? rid
    @room_events[rid] << e
  end
  @room_events.each do |rid,events|
    events.uniq!
  end
end

@track_rooms = {}
begin
  @events.each do |e|
    rid = e.conference_room_id
    r = @room_map[rid]
    tid = e.conference_track_id
    @track_rooms[tid] = [] unless @track_rooms.has_key? tid
    @track_rooms[tid] << r
  end
  @track_rooms.each do |tid,rooms|
    rooms.uniq!
  end
end

@date_tracks = {}
@date_track_name = {} # official name of the day
begin
  @events.group_by{|e| [e.start_datetime.strftime("%Y-%m-%d"), e.conference_track_id]}.each do |(date,tid), events|
    if not @date_tracks.has_key? date
      @date_tracks[date] = []
      @date_track_name[date] = events[0].start_datetime.strftime('%A %F')
    end
    @date_tracks[date] << tid
  end
end

@event_files = {}
@event_files_by_aid = {}
begin
  # WARNING! changing the order of columns here messes up the values, VERY FRAGILE!
  Event_attachment.select({:public => true}, {:columns => [:attachment_type, :filename, :event_id, :event_attachment_id, :attachment_type, :mime_type, :title]}).each do |ea|
    #next unless @event_map.has_key? ea.event_id

    #puts "AT=\"#{ea.attachment_type}\" -- EID=\"#{ea.event_id}\" -- EAID=\"#{ea.event_attachment_id}\" -- AT=\"#{ea.attachment_type}\" MT=\"#{ea.mime_type}\" -- F=\"#{ea.filename}\" -- T=\"#{ea.title}\""
    @event_files[ea.event_id] = [] unless @event_files.has_key? ea.event_id
    @event_files[ea.event_id] << ea
    @event_files_by_aid[ea.event_attachment_id] = ea
    raise "attachment without filename for event_id=#{ea.event_id} and event_attachment_id=#{ea.event_attachment_id}" unless (not ea.filename.nil?) and (ea.filename.length > 0)
  end
end

@event_files_to_save = {}
def save_event_attachment(event_attachment_id)
  @event_files_to_save[event_attachment_id] = 1
end
def attachment_href(event, attachment)
  return "#{event.event_id}/#{attachment.event_attachment_id}_#{attachment.filename}"
end
def attachment_title(attachment)
  if (not attachment.title.nil?) and (attachment.title.length > 0) then
    title = attachment.title
  else
    title = attachment.filename
  end
  if (not attachment.attachment_type.nil?) and (attachment.attachment_type.length > 0) then
    title = "#{title} (#{attachment.attachment_type})"
  end
  return title
end

def ical(calname, filename, events)
  eol = $\
  $\ = "\r\n"
  o = @output_dir + '/' + filename
  # puts "Rendering #{o}"
  File.open(o, File::CREAT|File::WRONLY|File::TRUNC) do |f|
    # use print here and not puts, as ics files MUST be CRLF (as of RFC2445) and
    # $\ only affects print, and not puts
    f.print "BEGIN:VCALENDAR"
    f.print "VERSION:2.0"
    f.print "PRODID:-//Pentabarf//Schedule 0.3//EN"
    f.print "CALSCALE:GREGORIAN"
    f.print "METHOD:PUBLISH"
    f.print "X-WR-CALDESC;VALUE=TEXT:Schedule of sessions for #{calname}"
    f.print "X-WR-CALNAME;VALUE=TEXT:#{calname} Schedule"
    f.print "X-WR-TIMEZONE;VALUE=TEXT:#{@timezone}"
    events.sort_by{|e| e.start_datetime}.each do |event|
      f.print "BEGIN:VEVENT"
      f.print "METHOD:PUBLISH"
      f.print "UID:#{event.event_id}@#{@conference.acronym}@fosdem.org"
      f.print "TZID:#{@timezone.gsub('/', '-')}"
      f.print "DTSTART:#{event.start_datetime.strftime('%Y%m%dT%H%M%S')}"
      f.print "DTEND:#{event.end_datetime.strftime('%Y%m%dT%H%M%S')}"
      # having both DTEND and DURATION breaks Apple's iCal, go figure
      #f.print "DURATION:PT#{event.duration.hour.to_s + 'H'}"
      f.print "SUMMARY:#{event.title}"
      if event.abstract.to_s.length > 0 then
        f.print "DESCRIPTION: #{event.abstract.to_s.gsub(/[\r\n]/,'')}"
      end
      f.print "CLASS:PUBLIC"
      f.print "STATUS:CONFIRMED"
      f.print "CATEGORIES:#{event.conference_track}"
      f.print "URL:#{@conference.export_base_url}event/#{event.slug.urlify}"
      f.print "LOCATION:#{event.conference_room}"
      (@event_speakers[event.event_id] or []).each do |speaker|
        f.print "ATTENDEE;ROLE=REQ-PARTICIPANT;CUTYPE=INDIVIDUAL;CN=\"#{speaker.name.namify}\":invalid:nomail"
      end
      f.print "END:VEVENT"
    end #event
    f.print "END:VCALENDAR"
  end #f
  $\ = eol
end #ical

#################################################################################################

total += 1 if export_sql
total += 1 if export_php
total += 1 if export_mobile
total += 1 if export_xml
total += 2 if export_xcal
total += (1 + 2 + 1 + 1 + 1 + 1 + 1 + 1 + 1) if export_schedule

#################################################################################################

pbar = ProgressBar.new("Exporting", total)
pbar.long_running
pbar.bar_mark = '#'

if export_odf then
  @rooms.each do |@room|
    roomevents = @events.select{|e| e.conference_room_id==@room.conference_room_id}
    next if roomevents.empty?
    roomevents.group_by{|e| e.start_datetime.to_date}.each do |@day, @roomevents|
      rxmlfile('odf', "odf/#{@room.conference_room.urlify}-#{@day.strftime("%a").downcase}.xml", false)
      pbar.inc
    end
  end

  #@tracks.each do |track|
  #  @track = track
  #  (@events_by_track[track.conference_track_id] or []).group_by{|e| e.start_datetime.to_date}.each do |@day, elist|
  #    elist.group_by{|e| e.conference_room_id}.each do |rid, @dayevents|
  #      @room = @room_map[rid]
  #      rxmlfile('odf', "odf/#{track.conference_track.urlify}-#{@room.conference_room.urlify}-#{@day.strftime("%a").downcase}.xml", false)
  #    end
  #  end
  #end
end

if export_sql then
  mkfile 'schedule.sql' do |f|
    f.puts """
DROP TABLE IF EXISTS schedule;
CREATE TABLE schedule (
  t           ENUM('event', 'speaker') NOT NULL,
  url         VARCHAR(1024) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,
  title       TEXT CHARACTER SET utf8 NOT NULL,
  subtitle    TEXT CHARACTER SET utf8 NULL,
  abstract    TEXT CHARACTER SET utf8 NULL,
  description TEXT CHARACTER SET utf8 NULL,
  FULLTEXT (title,subtitle,abstract,description)
) TYPE=MyISAM;

"""

    def s(o)
      return "NULL" if o.nil? or o.empty?
      return o.sqlify.strip
    end #s

    @events.each do |event|
      f.puts "INSERT INTO schedule(t,url,title,subtitle,abstract,description) VALUES('event', #{event.slug.urlify.sqlify}, #{event.title.sqlify}, #{s(event.subtitle)}, #{s(event.abstract)}, #{s(event.description)});"
    end #@events
    f.puts
    @speakers.each do |speaker|
      f.puts "INSERT INTO schedule(t,url,title,subtitle,abstract,description) VALUES('speaker', #{speaker.name.urlify.sqlify}, #{speaker.name.namify.sqlify}, NULL, #{s(speaker.abstract)}, #{s(speaker.description)});"
    end #@speakers
  end #f
  pbar.inc
  exit 0 if ENV.has_key? 'ONLYSQL'
end

if export_mobile then
  rxmlfile('mobile', 'mobile', false)
  pbar.inc
  @events.each do |event|
    @event = event
    rxmlfile('event-mobile', "mobile/event/#{event.slug.urlify}", false)
    pbar.inc
  end
  @speakers.each do |speaker|
    @speaker = speaker
    next if @speaker.conference_person_id.nil?
    rxmlfile('speaker-mobile', "mobile/speaker/#{speaker.name.urlify}", false)
    pbar.inc
  end
end
exit 0 if ENV.has_key? 'ONLYMOBILE'

if export_schedule or export_mobile then
  # puts "Rendering person pictures"
  images = Person_image.select({})
  images.each do |img|
    next unless img.public
    next unless @speaker_map.has_key? img.person_id
    next unless img.image.length > 0
    speaker = @speaker_map[img.person_id]
    @speaker_images[img.person_id] = img
    IMAGE_SIZES.each do |size|
      ext = mime_to_ext(img.mime_type)
      f = "images/speaker/#{speaker.name.urlify}-#{size}x#{size}.#{ext}"
      #puts "rendering image #{f}"
      begin
        write_file(f, resize_image(img.image, size, img.mime_type)) #'png'))
      rescue => e
        puts "WARNING: failed to render person image for person_id=#{img.person_id}: #{e.message}"
      end
    end
  end
end

if export_xml then
  rxmlfile('xml', "schedule.#{@lang}.xml", false)
  pbar.inc
end

if export_xcal then
  begin
    @xcal_events = @events
    @xcal_cal = "#{@conference.acronym}"
    rxmlfile('xcal', "schedule.#{@lang}.xcs", false)
    pbar.inc
  end
  ical("#{@conference.acronym}", "schedule.#{@lang}.ics", @events)
  pbar.inc
  @tracks.each do |track|
    track_events = (@events_by_track[track.conference_track_id] or [])
    ical("#{@conference.acronym} (#{track.conference_track})", "track/#{track.conference_track.urlify}.ics", track_events)
    pbar.inc
    @xcal_events = track_events
    @xcal_cal = "#{@conference.acronym} (#{track.conference_track})"
    rxmlfile('xcal', "track/#{track.conference_track.urlify}.xcs", false)
    pbar.inc
  end
end

if export_schedule then
  @urlprefix = ''
  rxmlfile('days', 'days')
  pbar.inc
  begin
    @urlprefix = '../'
    [1, 2].each do |@day|
      rxmlfile('days', "day/#{@day}")
      pbar.inc
    end
  end
  rxmlfile('rooms', 'rooms')
  pbar.inc
  @speakers_per_row = 4
  rxmlfile('allspeakers', 'allspeakers')
  pbar.inc
  rxmlfile('maintracks', 'maintracks')
  pbar.inc
  rxmlfile('tracks', 'tracks')
  pbar.inc
  rxmlfile('devrooms', 'devrooms')
  pbar.inc
  rxmlfile('events', 'events')
  pbar.inc

  @speakers.each do |speaker|
    @speaker = speaker
    rxmlfile('speaker', "speaker/#{speaker.name.urlify}")
    pbar.inc
  end

  @events.each do |event|
    @event = event
    if @event_files.has_key? event.event_id then
      @files = @event_files[event.event_id]
    else
      @files = []
    end
    rxmlfile('event', "event/#{event.slug.urlify}")
    pbar.inc
  end

  @no_speaker_image = true
  @tracks.each do |track|
    @track = track
    @track_events = (@events_by_track[track.conference_track_id] or [])
    rxmlfile('track', "track/#{@track.conference_track.urlify}")
    pbar.inc
  end

  @rooms.each do |room|
    @room = room
    rxmlfile('room', "room/#{room.conference_room.urlify}")
    pbar.inc
  end
end

if export_php then
mkfile 'includes/maps.php' do |f|
  f.puts "<?php"
  f.puts '$PENTABARF_EVENT_TITLE_BY_URL = array();'
  f.puts '$PENTABARF_EVENT_ID_BY_URL    = array();'
  f.puts '$PENTABARF_PERSON_NAME_BY_URL = array();'
  f.puts '$PENTABARF_PERSON_ID_BY_URL   = array();'
  f.puts '$PENTABARF_TRACK_NAME_BY_URL  = array();'
  f.puts '$PENTABARF_ROOM_NAME_BY_URL   = array();'
  f.puts '$PENTABARF_ROOM_GEO_BY_URL    = array();'
  f.puts '$PENTABARF_DAY_NAME_BY_ID     = array();'
  f.puts '$PENTABARF_DAY_NAME_BY_URL    = array();'
  f.puts '$PENTABARF_DAY_ID_BY_URL      = array();'
  f.puts

  @events.each do |e|
    raise "slug is nil for event #{e.title} (#{e.event_id})" if e.slug.nil?
    f.puts "$PENTABARF_EVENT_TITLE_BY_URL[#{e.slug.urlify.php}] = #{e.title.php};"
    f.puts "$PENTABARF_EVENT_ID_BY_URL[#{e.slug.urlify.php}] = #{e.event_id};"
  end
  f.puts
  @speakers.each do |s|
    f.puts "$PENTABARF_PERSON_NAME_BY_URL[#{s.name.urlify.php}] = #{s.name.namify.php};"
    f.puts "$PENTABARF_PERSON_ID_BY_URL[#{s.name.urlify.php}] = #{s.person_id};"
  end
  f.puts
  @tracks.each do |t|
    f.puts "$PENTABARF_TRACK_NAME_BY_URL[#{t.conference_track.urlify.php}] = #{t.conference_track.php};"
  end
  @rooms.each do |r|
    f.puts "$PENTABARF_ROOM_NAME_BY_URL[#{r.conference_room.urlify.php}] = #{r.conference_room.php};"
  end
  @rooms.each do |r|
    geo = @room_geo[r.conference_room.urlify]
    unless geo.nil? then
      f.puts "$PENTABARF_ROOM_GEO_BY_URL[#{r.conference_room.urlify.php}] = array(#{geo[0].php}, #{geo[1].php});"
    end
  end #rooms
  begin
    first_day = @events.map{|e| e.start_datetime.to_date}.min
    @events.map{|e| e.start_datetime.to_date}.uniq.sort.each do |d|
      id = (d - first_day) + 1
      f.puts "$PENTABARF_DAY_NAME_BY_ID[#{id}] = #{d.strftime("%A %F").php};"
      f.puts "$PENTABARF_DAY_NAME_BY_URL[#{d.strftime("%a").downcase.php}] = #{d.strftime("%A %F").php};"
      f.puts "$PENTABARF_DAY_ID_BY_URL[#{d.strftime("%a").downcase.php}] = #{id};"
    end
  end
end #f
pbar.inc
end #export_php

if export_schedule then
  h = {}
  @event_files_to_save.keys.each do |aid|
    ea = @event_files_by_aid[aid]
    event = @event_map[ea.event_id]
    raise "failed to find event with id \"#{ea.event_id}\" in event_map" if event.nil?
    l = nil
    unless h.has_key? event.event_id then
      x = {}
      x['event'] = event
      x['attachments'] = []
      h[event.event_id] = x
    end
    h[event.event_id]['attachments'] << ea
  end
  @attachments = h.values
  rxmlfile('attachments', "attachments")
end

pbar.finish

unless @event_files_to_save.empty? then
  efbar = ProgressBar.new("Attachments", @event_files_to_save.keys.count)
  @event_files_to_save.keys.each do |aid|
    a = @event_files_by_aid[aid]
    unless a.nil? then
      filename = a.filename
      d = "#{@output_dir}/event/#{a.event_id}"
      data = Event_attachment.select_single({:event_attachment_id => aid}, {:columns => [:data]})
      File.makedirs(d) unless File.directory? d
      fqfilename = "#{d}/#{a.event_attachment_id}_#{filename}"
      outfile = File.new(fqfilename, 'wb')
      outfile.puts(data.data)
      outfile.close
    end
    efbar.inc
  end
  efbar.finish
end

exit 0

